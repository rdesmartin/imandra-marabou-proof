#logic;;
let rec is_bounded (vars: real list) (upper_bounds: real list) (lower_bounds: real list) =
  match vars, upper_bounds, lower_bounds with
        | [], [], [] -> true
        | x::xs, u::us, l::ls ->
            if x >=. l && x <=. u
            then is_bounded xs us ls
            else false
        | _ -> false

let rec dot_product x  y =
        match x, y with
        | [], [] -> 0.
        | x1::xs, y1::ys -> x1 *. y1 +. (dot_product xs ys)
        | _ -> 0. (* TODO handle error case *)

axiom dot_product_symmetry x y =
    dot_product x y = dot_product y x
    [@@auto][@@rw]

let rec null_product (tableau: real list list) (x: real list) =
    match tableau, x with
    | [], [] -> true
    | row::tl, _ -> dot_product row x = 0. && (null_product tl x)
    | _ -> false

lemma zero_dot_product_r x tableau row =
    dot_product row x = 0. && null_product tableau x
    ==> null_product (tableau @ [row]) x = true
[@@auto][@@rw]

lemma zero_dot_product_l x tableau row =
    dot_product row x = 0. && null_product tableau x
    ==> null_product (row::tableau) x = true
[@@auto][@@rw]

lemma zero_dot_product_mult row x c =
    dot_product row x = 0. ==>
    c *. (dot_product row x) = 0.
[@@auto][@@rw]

lemma zero_dot_product_add row1 row2 x  =
    dot_product row1 x = 0. && dot_product row2 x = 0.==>
    (dot_product row1 x) +. (dot_product row2 x) = 0.
[@@auto][@@rw]

let kernel_vector_for_any_row_conv tableau x row k =
(List.mem row tableau && dot_product row x = 0.) ==>
    null_product tableau x
verify kernel_vector_for_any_row_conv [@@auto]

let kernel_vector_for_any_row tableau x row =
    null_product tableau x && List.mem row tableau
    ==> dot_product row x = 0.
verify kernel_vector_for_any_row

lemma kernel_vector_for_any_combination tableau x y =
    null_product tableau x
    ==> dot_product x (compute_combination y tableau) = 0.
[@@auto][@@rw]

lemma bounds_combination row x upper_bounds lower_bounds c =
    compute_row_upper_bound row upper_bounds lower_bounds = c
    <==> (is_bounded x upper_bounds lower_bounds
         && dot_product x row <=. c) = true

lemma contradiction_implies_negative_row x y tableau upper_bounds lower_bounds =
         check_contradiction y tableau upper_bounds lower_bounds
         <==> (is_bounded x upper_bounds lower_bounds
         && dot_product x y <. 0.) = true
     [@@auto]

(* lemma contradiction_implies_negative_row x y tableau upper_bounds lower_bounds =
    (check_contradiction y tableau upper_bounds lower_bounds [@trigger rw] &&
     is_bounded x upper_bounds lower_bounds) ==>
    dot_product x (compute_combination y tableau (M.empty)) <. 0. = true
[@@auto] [@@rw]

axiom dot_product_check_contradiction_eq x y tableau upper_bounds lower_bounds =
    ( is_bounded x upper_bounds lower_bounds &&
    dot_product x (compute_combination y tableau <. 0. [@trigger rw]) ==>
    check_contradiction y tableau upper_bounds lower_bounds = true
[@@rw]


theorem contradiction_verification x contradiction tableau upper_bounds lower_bounds =
    is_bounded x upper_bounds lower_bounds &&
    check_contradiction contradiction tableau upper_bounds lower_bounds ==>
    not (null_prod tableau x)
    [@@auto] *)
